# Software Testing, Automation, and Quality Assurance

## Repository Overview

This repository showcases my experience and skills in applying software engineering testing strategies and practices as part of the software development lifecycle, including requirements analysis, verification and validation, and quality management. The items in the repository demonstrate the ability to translate user requirements into actionable development plans and integrate  software testing strategies to ensure all user requirements are fulfilled. Inside this repository, you will find:

* Phonebook Mobile App (Backend): This application manages back-end services for a phonebook mobile application.
  
* Contact.java: Object class to create a contact entry.
  
* ContactService.java: Service class that manages Contact data and functionality.
  
* ContactServiceTest.java: Junit coverage tests to ensure the ContactService class fulfills all user requirements. The unit tests were designed with obscure structure-based methods.
  
* ContactTest.java: Junit coverage tests to ensure the Contact object contains all of the user-required characteristics. 


## Experience and Knowledge Gained:

I had the opportunity to develop a backend for a mobile application for a client at Grand Strand Systems. This project encompassed several key components: Contact, Task, and Appointment services. Each component featured an object class and a service class to manage its respective functionalities, ensuring a modular and maintainable codebase.


## Backend Development:

* Component Design: Developed the Contact, Task, and Appointment components, focusing on creating well-defined object and service classes to manage each componentâ€™s operations efficiently.
* Requirements-Based Testing: Employed a specification-based approach to design unit tests, directly derived from the software requirements provided by the client. This approach ensured that all critical functionality was tested comprehensively.

## Testing and Quality Assurance:

* JUnit Tests: Created and implemented JUnit tests to verify that each component met the specified requirements. These tests included conditions such as unique ID constraints, mandatory fields, and character limits.
* Test Design Techniques: Utilized equivalence partitioning and boundary value analysis to design effective unit tests. This involved testing valid, invalid, and null inputs to ensure the robustness of each component.
* Test Lifecycle Management: Followed a structured approach to testing, incorporating setup, exercise, verify, and teardown stages. This ensured that the tests were well-organized and easy to maintain.

## Tools and Methodologies:

* IntelliJ IDE: Utilized IntelliJ for developing code and running unit tests, taking advantage of its comprehensive testing and coverage analysis features.
* Coverage Analysis: Achieved outstanding test coverage results, with 100% class coverage, 87% method coverage, and 83% line coverage. This high level of coverage demonstrated the effectiveness of the unit tests in verifying the backend services.
* Lifecycle Annotations and Assertions: Applied lifecycle annotations and assertions in JUnit to ensure thorough and accurate testing of the components.

## Reflection:

This project provided invaluable insights into the importance of rigorous testing and quality assurance in software development. I learned to anticipate and mitigate biases, understand the critical nature of thorough testing, and recognize the potential consequences of undetected errors. The experience underscored the necessity of developing and adhering to effective test design approaches, especially under time constraints.

The project highlighted the significant impact of quality assurance on software reliability and instilled a mindset of continuous improvement and vigilance in testing practices. Moving forward, I am committed to applying these principles in all my development projects, ensuring high-quality and reliable software solutions.


